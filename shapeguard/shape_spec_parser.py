# The file was automatically generated by Lark v0.6.4
#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser with a standard lexer
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark.
#
#    It is licensed under GPLv2 or above.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, contact me via email.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    See <http://www.gnu.org/licenses/>.
#
#


import types
from functools import wraps, partial
from contextlib import contextmanager

Str = type(u'')

def smart_decorator(f, create_decorator):
    if isinstance(f, types.FunctionType):
        return wraps(f)(create_decorator(f, True))

    elif isinstance(f, (type, types.BuiltinFunctionType)):
        return wraps(f)(create_decorator(f, False))

    elif isinstance(f, types.MethodType):
        return wraps(f)(create_decorator(f.__func__, True))

    elif isinstance(f, partial):
        # wraps does not work for partials in 2.7: https://bugs.python.org/issue3445
        return create_decorator(f.__func__, True)

    else:
        return create_decorator(f.__func__.__call__, True)




try:
    from contextlib import suppress     # Python 3
except ImportError:
    @contextmanager
    def suppress(*excs):
        '''Catch and dismiss the provided exception

        >>> x = 'hello'
        >>> with suppress(IndexError):
        ...     x = x[10]
        >>> x
        'hello'
        '''
        try:
            yield
        except excs:
            pass


# ############################# Custom Fixes ################################# #
class LarkError(Exception):
    pass


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


class UnexpectedCharacters(LarkError):
    pass


class UnexpectedToken(LarkError):
    pass

class Discard(LarkError):
    pass

class TransformerChain(LarkError):
    pass


class Meta:
    pass


class Transformer:
    """Visits the tree recursively, starting with the leaves and finally the root (bottom-up)

    Calls its methods (provided by user via inheritance) according to tree.data
    The returned value replaces the old one in the structure.

    Can be used to implement map or reduce.
    """

    def _call_userfunc(self, tree, new_children=None):
        # Assumes tree is already transformed
        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            if getattr(f, 'meta', False):
                return f(children, tree.meta)
            elif getattr(f, 'inline', False):
                return f(*children)
            elif getattr(f, 'whole_tree', False):
                if new_children is not None:
                    raise NotImplementedError("Doesn't work with the base Transformer class")
                return f(tree)
            else:
                return f(children)

    def _transform_children(self, children):
        for c in children:
            try:
                yield self._transform_tree(c) if isinstance(c, Tree) else c
            except Discard:
                pass

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree):
        return self._transform_tree(tree)

    def __mul__(self, other):
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        "Default operation on tree (for override)"
        return Tree(data, children, meta)

    # @classmethod
    # def _apply_decorator(cls, decorator, **kwargs):
    #     mro = getmro(cls)
    #     assert mro[0] is cls
    #     libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
    #     for name, value in getmembers(cls):
    #         if name.startswith('_') or name in libmembers:
    #             continue
    #
    #         setattr(cls, name, decorator(value, **kwargs))
    #     return cls


# ############################################################################ #


class Tree(object):
    def __init__(self, data, children, meta=None):
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self):
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return 'Tree(%s, %s)' % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            return [ indent_str*level, self._pretty_label(), '\t', '%s' % (self.children[0],), '\n']

        l = [ indent_str*level, self._pretty_label(), '\n' ]
        for n in self.children:
            if isinstance(n, Tree):
                l += n._pretty(level+1, indent_str)
            else:
                l += [ indent_str*(level+1), '%s' % (n,), '\n' ]

        return l

    def pretty(self, indent_str='  '):
        return ''.join(self._pretty(0, indent_str))

class Indenter:
    def __init__(self):
        self.paren_level = 0
        self.indent_level = [0]

    def handle_NL(self, token):
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit('\n', 1)[1] # Tabs and spaces
        indent = indent_str.count(' ') + indent_str.count('\t') * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            assert indent == self.indent_level[-1], '%s != %s' % (indent, self.indent_level[-1])

    def process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                for t in self.handle_NL(token):
                    yield t
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, '')

        assert self.indent_level == [0], self.indent_level

    # XXX Hack for ContextualLexer. Maybe there's a more elegant solution?
    @property
    def always_accept(self):
        return (self.NL_type,)


class Token(Str):
    __slots__ = ('type', 'pos_in_stream', 'value', 'line', 'column', 'end_line', 'end_column')

    def __new__(cls, type_, value, pos_in_stream=None, line=None, column=None):
        self = super(Token, cls).__new__(cls, value)
        self.type = type_
        self.pos_in_stream = pos_in_stream
        self.value = value
        self.line = line
        self.column = column
        self.end_line = None
        self.end_column = None
        return self

    @classmethod
    def new_borrow_pos(cls, type_, value, borrow_t):
        return cls(type_, value, borrow_t.pos_in_stream, line=borrow_t.line, column=borrow_t.column)

    def __reduce__(self):
        return (self.__class__, (self.type, self.value, self.pos_in_stream, self.line, self.column, ))

    def __repr__(self):
        return 'Token(%s, %r)' % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.pos_in_stream, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return Str.__eq__(self, other)

    __hash__ = Str.__hash__


class LineCounter:
    def __init__(self):
        self.newline_char = '\n'
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def feed(self, token, test_newline=True):
        """Consume a token and calculate the new line & column.

        As an optional optimization, set test_newline=False is token doesn't contain a newline.
        """
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = self.char_pos + token.rindex(self.newline_char) + 1

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1

class _Lex:
    "Built to serve both Lexer and ContextualLexer"
    def __init__(self, lexer, state=None):
        self.lexer = lexer
        self.state = state

    def lex(self, stream, newline_types, ignore_types):
        newline_types = list(newline_types)
        ignore_types = list(ignore_types)
        line_ctr = LineCounter()

        t = None
        while True:
            lexer = self.lexer
            for mre, type_from_index in lexer.mres:
                m = mre.match(stream, line_ctr.char_pos)
                if m:
                    value = m.group(0)
                    type_ = type_from_index[m.lastindex]
                    if type_ not in ignore_types:
                        t = Token(type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column)
                        if t.type in lexer.callback:
                            t = lexer.callback[t.type](t)
                        yield t
                    else:
                        if type_ in lexer.callback:
                            t = Token(type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column)
                            lexer.callback[type_](t)

                    line_ctr.feed(value, type_ in newline_types)
                    if t:
                        t.end_line = line_ctr.line
                        t.end_column = line_ctr.column

                    break
            else:
                if line_ctr.char_pos < len(stream):
                    raise UnexpectedCharacters(stream, line_ctr.char_pos, line_ctr.line, line_ctr.column, state=self.state)
                break

        if t:
            t.end_line = line_ctr.line
            t.end_column = line_ctr.column

class UnlessCallback:
    def __init__(self, mres):
        self.mres = mres

    def __call__(self, t):
        for mre, type_from_index in self.mres:
            m = mre.match(t.value)
            if m:
                t.type = type_from_index[m.lastindex]
                break
        return t


from functools import partial, wraps


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        res = self.node_builder(children)

        if children and isinstance(res, Tree):
            for a in children:
                if isinstance(a, Tree):
                    res.meta.line = a.meta.line
                    res.meta.column = a.meta.column
                elif isinstance(a, Token):
                    res.meta.line = a.line
                    res.meta.column = a.column
                break

            for a in reversed(children):
                # with suppress(AttributeError):
                if isinstance(a, Tree):
                    res.meta.end_line = a.meta.end_line
                    res.meta.end_column = a.meta.end_column
                elif isinstance(a, Token):
                    res.meta.end_line = a.end_line
                    res.meta.end_column = a.end_column

                break

        return res


class ChildFilter:
    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        return self.node_builder(filtered)

class ChildFilterLALR(ChildFilter):
    "Optimized childfilter for LALR (assumes no duplication in parse tree, so it's safe to change it)"

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:   # Optimize for left-recursion
                    filtered = children[i].children
            else:
                filtered.append(children[i])

        return self.node_builder(filtered)

def _should_expand(sym):
    return not sym.is_term and sym.name.startswith('_')

def maybe_create_child_filter(expansion, keep_all_tokens, ambiguous):
    to_include = [(i, _should_expand(sym)) for i, sym in enumerate(expansion)
                  if keep_all_tokens or not (sym.is_term and sym.filter_out)]

    if len(to_include) < len(expansion) or any(to_expand for i, to_expand in to_include):
        return partial(ChildFilter if ambiguous else ChildFilterLALR, to_include)


class Callback(object):
    pass


def inline_args(func):
    @wraps(func)
    def f(children):
        return func(*children)
    return f



class ParseTreeBuilder:
    def __init__(self, rules, tree_class, propagate_positions=False, keep_all_tokens=False, ambiguous=False):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.always_keep_all_tokens = keep_all_tokens
        self.ambiguous = ambiguous

        self.rule_builders = list(self._init_builders(rules))

        self.user_aliases = {}

    def _init_builders(self, rules):
        for rule in rules:
            options = rule.options
            keep_all_tokens = self.always_keep_all_tokens or (options.keep_all_tokens if options else False)
            expand_single_child = options.expand1 if options else False

            wrapper_chain = filter(None, [
                (expand_single_child and not rule.alias) and ExpandSingleChild,
                maybe_create_child_filter(rule.expansion, keep_all_tokens, self.ambiguous),
                self.propagate_positions and PropagatePositions,
            ])

            yield rule, wrapper_chain


    def create_callback(self, transformer=None):
        callback = Callback()

        i = 0
        for rule, wrapper_chain in self.rule_builders:
            internal_callback_name = '_cb%d_%s' % (i, rule.origin)
            i += 1

            user_callback_name = rule.alias or rule.origin.name
            try:
                f = getattr(transformer, user_callback_name)
                assert not getattr(f, 'meta', False), "Meta args not supported for internal transformer"
                # XXX InlineTransformer is deprecated!
                if getattr(f, 'inline', False):
                    f = inline_args(f)
            except AttributeError:
                f = partial(self.tree_class, user_callback_name)

            self.user_aliases[rule] = rule.alias
            rule.alias = internal_callback_name

            for w in wrapper_chain:
                f = w(f)

            if hasattr(callback, internal_callback_name):
                raise GrammarError("Rule '%s' already exists" % (rule,))
            setattr(callback, internal_callback_name, f)

        return callback



class _Parser:
    def __init__(self, parse_table, callbacks):
        self.states = parse_table.states
        self.start_state = parse_table.start_state
        self.end_state = parse_table.end_state
        self.callbacks = callbacks

    def parse(self, seq, set_state=None):
        i = 0
        token = None
        stream = iter(seq)
        states = self.states

        state_stack = [self.start_state]
        value_stack = []

        if set_state: set_state(self.start_state)

        def get_action(key):
            state = state_stack[-1]
            try:
                return states[state][key]
            except KeyError:
                expected = states[state].keys()
                raise UnexpectedToken(token, expected, state=state)  # TODO filter out rules from expected

        def reduce(rule):
            size = len(rule.expansion)
            if size:
                s = value_stack[-size:]
                del state_stack[-size:]
                del value_stack[-size:]
            else:
                s = []

            value = self.callbacks[rule](s)

            _action, new_state = get_action(rule.origin.name)
            assert _action is Shift
            state_stack.append(new_state)
            value_stack.append(value)

        # Main LALR-parser loop
        for i, token in enumerate(stream):
            while True:
                action, arg = get_action(token.type)
                assert arg != self.end_state

                if action is Shift:
                    state_stack.append(arg)
                    value_stack.append(token)
                    if set_state: set_state(arg)
                    break # next token
                else:
                    reduce(arg)

        while True:
            _action, arg = get_action('$END')
            if _action is Shift:
                assert arg == self.end_state
                val ,= value_stack
                return val
            else:
                reduce(arg)


class Symbol(object):
    is_term = NotImplemented

    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return '%s(%r)' % (type(self).__name__, self.name)

class Terminal(Symbol):
    is_term = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out


class NonTerminal(Symbol):
    is_term = False

class Rule(object):
    """
        origin : a symbol
        expansion : a list of symbols
    """
    def __init__(self, origin, expansion, alias=None, options=None):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.options = options

    def __str__(self):
        return '<%s : %s>' % (self.origin, ' '.join(map(str,self.expansion)))

    def __repr__(self):
        return 'Rule(%r, %r, %r, %r)' % (self.origin, self.expansion, self.alias, self.options)


class RuleOptions:
    def __init__(self, keep_all_tokens=False, expand1=False, priority=None):
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority

    def __repr__(self):
        return 'RuleOptions(%r, %r, %r)' % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
        )

Shift = 0
Reduce = 1
import re
MRES = (
    [('(?P<CNAME>(?:_|(?:[A-Z]|[a-z]))(?:(?:(?:_|(?:[A-Z]|[a-z]))|[0-9]))*)|(?P<WS>(?:[ \t\x0c'
      '\r\n'
      '])+)|(?P<INT>(?:[0-9])+)|(?P<__ANON_0>\\.\\.\\.)|(?P<COMMA>\\,)|(?P<LPAR>\\()|(?P<MINUS>\\-)|(?P<PLUS>\\+)|(?P<QMARK>\\?)|(?P<RPAR>\\))|(?P<SLASH>\\/)|(?P<STAR>\\*)',
      {1: 'CNAME',
       2: 'WS',
       3: 'INT',
       4: '__ANON_0',
       5: 'COMMA',
       6: 'LPAR',
       7: 'MINUS',
       8: 'PLUS',
       9: 'QMARK',
       10: 'RPAR',
       11: 'SLASH',
       12: 'STAR'})]
)
LEXER_CALLBACK = (
    {}
)
NEWLINE_TYPES = ['WS']
IGNORE_TYPES = ['WS']
class LexerRegexps: pass
lexer_regexps = LexerRegexps()
lexer_regexps.mres = [(re.compile(p), d) for p, d in MRES]
lexer_regexps.callback = {n: UnlessCallback([(re.compile(p), d) for p, d in mres])
                          for n, mres in LEXER_CALLBACK.items()}
lexer = _Lex(lexer_regexps)
def lex(stream):
    return lexer.lex(stream, NEWLINE_TYPES, IGNORE_TYPES)
RULES = {
    0: Rule(NonTerminal('start'), [NonTerminal('dim'), NonTerminal('__anon_star_0')], None, RuleOptions(False, False, None)),
    1: Rule(NonTerminal('start'), [NonTerminal('dim')], None, RuleOptions(False, False, None)),
    2: Rule(NonTerminal('dim'), [NonTerminal('sum')], None, RuleOptions(False, True, None)),
    3: Rule(NonTerminal('dim'), [NonTerminal('dynamic')], None, RuleOptions(False, True, None)),
    4: Rule(NonTerminal('dim'), [NonTerminal('wildcard')], None, RuleOptions(False, True, None)),
    5: Rule(NonTerminal('dim'), [NonTerminal('ellipsis')], None, RuleOptions(False, True, None)),
    6: Rule(NonTerminal('sum'), [NonTerminal('sum'), Terminal('MINUS'), NonTerminal('product')], 'sub', RuleOptions(False, True, None)),
    7: Rule(NonTerminal('sum'), [NonTerminal('sum'), Terminal('PLUS'), NonTerminal('product')], 'add', RuleOptions(False, True, None)),
    8: Rule(NonTerminal('sum'), [NonTerminal('product')], None, RuleOptions(False, True, None)),
    9: Rule(NonTerminal('product'), [NonTerminal('product'), Terminal('STAR'), NonTerminal('item')], 'mul', RuleOptions(False, True, None)),
    10: Rule(NonTerminal('product'), [NonTerminal('item')], None, RuleOptions(False, True, None)),
    11: Rule(NonTerminal('product'), [NonTerminal('product'), Terminal('SLASH'), NonTerminal('item')], 'div', RuleOptions(False, True, None)),
    12: Rule(NonTerminal('item'), [Terminal('LPAR'), NonTerminal('sum'), Terminal('RPAR')], None, RuleOptions(False, True, None)),
    13: Rule(NonTerminal('item'), [Terminal('CNAME')], 'name', RuleOptions(False, True, None)),
    14: Rule(NonTerminal('item'), [Terminal('CNAME'), Terminal('QMARK')], 'dynamic_name', RuleOptions(False, True, None)),
    15: Rule(NonTerminal('item'), [Terminal('INT')], 'number', RuleOptions(False, True, None)),
    16: Rule(NonTerminal('wildcard'), [Terminal('STAR')], None, RuleOptions(False, False, None)),
    17: Rule(NonTerminal('ellipsis'), [Terminal('__ANON_0')], None, RuleOptions(False, False, None)),
    18: Rule(NonTerminal('dynamic'), [Terminal('QMARK')], None, RuleOptions(False, False, None)),
    19: Rule(NonTerminal('__anon_star_0'), [NonTerminal('__anon_star_0'), Terminal('COMMA'), NonTerminal('dim')], None, None),
    20: Rule(NonTerminal('__anon_star_0'), [Terminal('COMMA'), NonTerminal('dim')], None, None),
}
parse_tree_builder = ParseTreeBuilder(RULES.values(), Tree)
class ParseTable: pass
parse_table = ParseTable()
STATES = {
    0: {0: (1, 14), 1: (1, 14), 2: (1, 14), 3: (1, 14), 4: (1, 14), 5: (1, 14), 6: (1, 14)},
    1: {0: (0, 29), 1: (1, 7), 2: (1, 7), 3: (1, 7), 4: (1, 7), 5: (0, 25), 6: (1, 7)},
    2: {3: (1, 4), 4: (1, 4)},
    3: {7: (0, 8), 8: (0, 4), 9: (0, 5), 10: (0, 12), 11: (0, 3), 12: (0, 26)},
    4: {0: (1, 15), 1: (1, 15), 2: (1, 15), 3: (1, 15), 4: (1, 15), 5: (1, 15), 6: (1, 15)},
    5: {1: (0, 10), 2: (0, 9), 6: (0, 6)},
    6: {0: (1, 12), 1: (1, 12), 2: (1, 12), 3: (1, 12), 4: (1, 12), 5: (1, 12), 6: (1, 12)},
    7: {1: (0, 10), 2: (0, 9), 3: (1, 2), 4: (1, 2)},
    8: {0: (1, 13), 1: (1, 13), 2: (1, 13), 3: (1, 13), 4: (1, 13), 5: (1, 13), 6: (1, 13), 13: (0, 0)},
    9: {8: (0, 4), 10: (0, 12), 11: (0, 3), 12: (0, 20), 7: (0, 8)},
    10: {8: (0, 4), 10: (0, 12), 11: (0, 3), 12: (0, 1), 7: (0, 8)},
    11: {3: (1, 5), 4: (1, 5)},
    12: {0: (1, 10), 1: (1, 10), 2: (1, 10), 3: (1, 10), 4: (1, 10), 5: (1, 10), 6: (1, 10)},
    13: {0: (1, 9), 1: (1, 9), 2: (1, 9), 3: (1, 9), 4: (1, 9), 5: (1, 9), 6: (1, 9)},
    14: {0: (0, 27), 7: (0, 8), 8: (0, 4), 9: (0, 7), 10: (0, 12), 11: (0, 3), 12: (0, 26), 13: (0, 30), 14: (0, 21), 15: (0, 2), 16: (0, 17), 17: (0, 19), 18: (0, 11)},
    15: {0: (0, 27), 7: (0, 8), 8: (0, 4), 9: (0, 7), 10: (0, 12), 11: (0, 3), 12: (0, 26), 13: (0, 30), 14: (0, 28), 15: (0, 2), 16: (0, 17), 17: (0, 19), 18: (0, 11), 19: (0, 16)},
    16: {3: (0, 18)},
    17: {3: (1, 3), 4: (1, 3)},
    18: {},
    19: {3: (1, 17), 4: (1, 17)},
    20: {0: (0, 29), 1: (1, 6), 2: (1, 6), 3: (1, 6), 4: (1, 6), 5: (0, 25), 6: (1, 6)},
    21: {3: (1, 19), 4: (1, 19)},
    22: {3: (1, 20), 4: (1, 20)},
    23: {3: (1, 0), 4: (0, 14)},
    24: {0: (0, 27), 7: (0, 8), 8: (0, 4), 9: (0, 7), 10: (0, 12), 11: (0, 3), 12: (0, 26), 13: (0, 30), 14: (0, 22), 15: (0, 2), 16: (0, 17), 17: (0, 19), 18: (0, 11)},
    25: {8: (0, 4), 10: (0, 31), 11: (0, 3), 7: (0, 8)},
    26: {0: (0, 29), 1: (1, 8), 2: (1, 8), 3: (1, 8), 4: (1, 8), 5: (0, 25), 6: (1, 8)},
    27: {3: (1, 16), 4: (1, 16)},
    28: {20: (0, 23), 3: (1, 1), 4: (0, 24)},
    29: {8: (0, 4), 10: (0, 13), 11: (0, 3), 7: (0, 8)},
    30: {3: (1, 18), 4: (1, 18)},
    31: {0: (1, 11), 1: (1, 11), 2: (1, 11), 3: (1, 11), 4: (1, 11), 5: (1, 11), 6: (1, 11)},
}
TOKEN_TYPES = (
    {0: 'STAR',
     1: 'PLUS',
     2: 'MINUS',
     3: '$END',
     4: 'COMMA',
     5: 'SLASH',
     6: 'RPAR',
     7: 'CNAME',
     8: 'INT',
     9: 'sum',
     10: 'item',
     11: 'LPAR',
     12: 'product',
     13: 'QMARK',
     14: 'dim',
     15: 'wildcard',
     16: 'dynamic',
     17: '__ANON_0',
     18: 'ellipsis',
     19: 'start',
     20: '__anon_star_0'}
)
parse_table.states = {s: {TOKEN_TYPES[t]: (a, RULES[x] if a is Reduce else x) for t, (a, x) in acts.items()}
                      for s, acts in STATES.items()}
parse_table.start_state = 15
parse_table.end_state = 18
class Lark_StandAlone:
    def __init__(self, transformer=None, postlex=None):
        callback = parse_tree_builder.create_callback(transformer=transformer)
        callbacks = {rule: getattr(callback, rule.alias or rule.origin, None) for rule in RULES.values()}
        self.parser = _Parser(parse_table, callbacks)
        self.postlex = postlex
    def parse(self, stream):
        tokens = lex(stream)
        if self.postlex: tokens = self.postlex.process(tokens)
        return self.parser.parse(tokens)
